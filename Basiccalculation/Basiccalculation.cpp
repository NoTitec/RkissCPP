
#include <iostream>
using namespace std;

int a = 1;
int b = 2;
//산술연산
//대입연산
//사칙연산

int out; //전역 변수
//어셈블리 data영역
//.data 초기값있는 경우 .bss 초기값 없는 경우
//.rodata 읽기 전용 데이터
//const는 읽기 전용으로 쓰이지만 C++에 반드시 .rodata영역에 저장하라는 말이 없다
//컴파일러가 해당 전역변수값을 저장없이 코드에서 찾아서 대입만 하는 경우도 확인 가능하다
//비주얼 스튜디오의경우 함수 내부에서는 스택영역에 실제로 저장되는 경우가 많다
int main()
{
    //함수 내부는 스택 메모리 영억 스택 메모리 영역에 잘못 접근해서 수정하면
    //치명적 문제 발생 가능

#pragma region 산술 연산
    std::cout << "Hello World!\n";
    a = b;
    a = b = 3;
    //대입연산 : 오른쪽에서 왼쪽으로 대입 후 가장 오른쪽 변수 반환

    //사칙연산
    a = b + 3;
    a = b - 3;
    a = b * 3;
    a = b / 3;
    a = b % 3;

    a += 3;

    //증감 연산자
    b=a++;
    b=++a;

    //연산자가 앞에 있으면 해당 문장 시작할 때 증가 뒤에 있으면 해당 문장 넘어갈 때 증가

    //연산자 우선순위
    //
    //어셈블리 보기 : 디버그 모드에서  ctrl+alt+d
#pragma endregion

#pragma region 비교연산
    //체력 0 시 사망
    //체력 30%이하일시 궁극기 발돌
    //경험치 100 이상시 레벨업

    bool isSame;
    bool isDifferent;
    bool isGreater;
    bool is;
    isSame = (a == b);

    isDifferent = (a != b);

    isGreater = (a > b);

    // > , >=

    
#pragma endregion
    bool test;
#pragma region 논리 연산
    //조건에 대한 논리적 사고가 필요할 때
    // 로그인시 아이디와 비밀번호가 둘다 같아야 한다
    //어셈블러로 열어보면 분석가능한데 논리 연산은 앞에 조건이나 뒤에 조건의 순서가 중요하다
    test = !isSame;
    int hp = 100;
    bool isinvincible = true;
    //a&&b
    test = (hp <= 0 && isinvincible == false);// 사망

    //a||b
    test = (hp > 0 || isinvincible == true);//생존
    //!(hp <= 0 && isinvincible == false); //사망
#pragma endregion
    //디버그 모드에서 변수에 마우스 가져다대면 뭐가 들어있는지 보여준다

#pragma region 비트 연산
    //언제 필요한가
    //비트 단위 조작 필요할 때
    // 대표적으로 bitflag
    //~ bitwise not
    // 단일 숫자의 모든 비트 대상 반전
    // & bitwise and
    // 두 숫자 모든 비트 쌍별로 and 연산

    // | bitwise or
    // 두 숫자 모든 비트 쌍별로 or 연산

    // ^ bitwise xor
    // 두 숫자 모든 비트 쌍 대상으로 xor한다
    //1 .같은 숫자 xor시 0이 나옴 2. 같은수 두 번 xor 하면 원래 수가 나옴

    //<<  왼쪽 넘어가는 비트는 버려지고 생성되는 비트는 0이다 *2 를 할때 컴파일러가 자주 보이는 패턴
    // >> 비트를 n만큼 오른쪽이동 오른쪽 넘어가는 비트는 버려지고 새로 생성되는 비트는 최상위 비트를 제외하고 0이다
    // 최상위 비트는 유지가 된다( 음수일 경우 유의해야 한다)

    // 0b0000 [무적][변이][스턴][공중부양]
    // 각 상태를 각각의 bool로 만들어 놓을 수도 있지만
    // 상태가 여러개일경우 관리 어려움
    // 각 상태를 비트열의 자리 수 로 의미를 부여하면 관리 용이

    //무적상태로 만든다
    
    unsigned char flag;//부호를 없애야 쉬프트 연산을 하더라도 부호비트가 딸려오지 않음
    flag = (1 << 3);//8로 대체가되지만 하드코딩되어있음 중간에 다른 값이 필요한 경우 이 코드가
    //작성된 코드를 모두 찾아 수정해야하는 불편함이 있음
    const int INVINCIBLE = 3; //불변상수로 설정함 (초기화 반듯 필요)

    //변이 상태 추가
    flag |= (1 << 2);

    //무적인지 확인
    //bitmask 이용
    bool invincible=(flag & (1 << 3)) != 0; //0이 아니면 1 0이면 0
    
    bool stunorinvincible = ((flag &0b1010) !=0 );
#pragma endregion
    //const 는 변경하면안되는 변수, 변수는 전역변수와 지역변수 생성시 전역을 데이터영역
    //지역은 스택에 생성된다
#pragma region 유의사항
    //변수의 유효범위
    //지역변수의 경우 함수의 {} 내부가 유효지역
    //같은 유효범위내 같은 이름의 변수는 존재 할 수 없음
    //전역변수와 지역변수는 같은 이름을 가질 수있어 원하지 않는 동작이 발생 할 수 있음

    //2)연산자 우선 순위
    //일일이 외우는건 비효율적 우선이 필요한 경우 괄호로 감싸주는 방법

    //3) 타입 변환
    // int 를 short,float , unsigned int 등으로 바꾸려고 하면 
    // 큰 자료형의 내용을 작은 자료형으로 옳기려고 할 경우 데이터의 손실이 발생한다
    //실수 변환시 정밀도 차이가 있어 데이터 손실 ㅏㄹ생이 가능하다
    //음수를 unsigned 로 바꾸려 할 경우 MSB해석 방법이 달라 값이 이상하게 바뀔 수 있다.

    //사칙 연산 관련
    //곱셈시 오버플로우 조심
    //나눗셈 0으로 하는 것 조심 0나누기는 존재하지 않으므로 빌드 실패한다
    //나눗셈시 int / int 는 결과도 int 로 생각하기 때문에 소수점 이하단위는 버려진다.
    //하나라도 float면 float가 나온다
#pragma endregion
}

